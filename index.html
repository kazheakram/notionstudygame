import React, { useState, useEffect, createContext, useContext, useRef } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, onAuthStateChanged } from 'firebase/auth';
import {
  getFirestore, doc, setDoc, updateDoc, onSnapshot, runTransaction, arrayUnion
} from 'firebase/firestore';

// --- Firebase Context ---
// This context will provide Firebase auth and Firestore instances to all components.
const FirebaseContext = createContext(null);

/**
 * FirebaseProvider component
 * Initializes Firebase, authenticates the user, and provides the Firebase instances
 * and user ID to its children via context.
 *
 * IMPORTANT: For this game to have real-time multiplayer functionality on GitHub Pages,
 * you MUST replace the placeholder firebaseConfig object below with your actual Firebase project's configuration.
 *
 * How to get your Firebase Config:
 * 1. Go to your Firebase Project Console (console.firebase.google.com).
 * 2. Click on "Project settings" (gear icon next to "Project overview").
 * 3. In the "Your apps" section, click the web icon (</>) to add a new web app.
 * 4. Follow the steps, and at the end, Firebase will provide you with a 'firebaseConfig' object.
 * 5. Copy that entire object and paste it below, replacing the existing firebaseConfig.
 */
function FirebaseProvider({ children }) {
  const [db, setDb] = useState(null);
  const [auth, setAuth] = useState(null);
  const [userId, setUserId] = useState(null);
  const [isAuthReady, setIsAuthReady] = useState(false);
  const [firebaseProviderMessage, setFirebaseProviderMessage] = useState(null); // New state for provider-level messages
  const [firebaseProviderMessageType, setFirebaseProviderMessageType] = useState('error'); // Type for provider-level messages

  // YOUR ACTUAL FIREBASE CONFIG HAS BEEN INSERTED HERE
  const firebaseConfig = {
    apiKey: "AIzaSyCK7wNoSjOCR1wajg0fuym4__3oOuSPS-Q",
    authDomain: "study-game-8522a.firebaseapp.com",
    projectId: "study-game-8522a",
    storageBucket: "study-game-8522a.firebasestorage.app",
    messagingSenderId: "917966145384",
    appId: "1:917966145384:web:6765cb4b1f55e8415638dd",
    measurementId: "G-V43C68JVJG"
  };

  // Determine the appId dynamically from the Firebase project ID for consistency
  // This will be used in Firestore paths like 'artifacts/{appId}/public/data/games/{gameId}'
  const effectiveAppId = (firebaseConfig.projectId && firebaseConfig.projectId !== "YOUR_PROJECT_ID")
    ? firebaseConfig.projectId
    : "default-app-id"; // Fallback for Canvas or if config is not set

  useEffect(() => {
    // Log the config being used for debugging
    console.log("Attempting Firebase initialization with config:", firebaseConfig);

    // Check if firebaseConfig is still the placeholder. If so, warn and do not initialize Firebase.
    // This check now primarily ensures the user has replaced the dummy config.
    if (!firebaseConfig.projectId || firebaseConfig.projectId === "YOUR_PROJECT_ID") {
      console.error("Firebase configuration is missing or incomplete. Multiplayer features will NOT work.");
      setFirebaseProviderMessage("üõë Multiplayer features offline: Please update Firebase config in App.js (FirebaseProvider component).");
      setFirebaseProviderMessageType('error');
      setIsAuthReady(false); // Keep isAuthReady false to show a clear message to the user.
      return;
    }

    try {
      // Initialize Firebase app
      const app = initializeApp(firebaseConfig);
      const firestore = getFirestore(app);
      const firebaseAuth = getAuth(app);

      setDb(firestore);
      setAuth(firebaseAuth);

      // Sign in anonymously and listen for auth state changes
      const unsubscribe = onAuthStateChanged(firebaseAuth, async (user) => {
        if (user) {
          console.log("Firebase Auth state changed: User is signed in with UID:", user.uid);
          setUserId(user.uid);
        } else {
          console.log("Firebase Auth state changed: No user, attempting anonymous sign-in.");
          // Attempt anonymous sign-in
          try {
            await signInAnonymously(firebaseAuth);
            console.log("Anonymous sign-in successful.");
          } catch (anonError) {
            console.error("Firebase Anonymous Auth Error during sign-in:", anonError);
            setFirebaseProviderMessage(`Firebase Authentication failed: ${anonError.message}. Please check Firebase Console Authentication settings.`);
            setFirebaseProviderMessageType('error');
            setIsAuthReady(false); // Authentication failed, cannot proceed.
            return; // Exit here if anonymous sign-in fails
          }
        }
        setIsAuthReady(true); // Auth state check complete and user (anonymous or otherwise) is obtained
        console.log("Firebase Auth is ready.");
        setFirebaseProviderMessage(null); // Clear any previous messages if successful
      });

      // Cleanup subscription on unmount
      return () => unsubscribe();
    } catch (error) {
      console.error("Failed to initialize Firebase app or get services:", error);
      setFirebaseProviderMessage(`Firebase initialization failed: ${error.message}. Please verify your firebaseConfig and network.`);
      setFirebaseProviderMessageType('error');
      setIsAuthReady(false);
    }
  }, [JSON.stringify(firebaseConfig)]); // Re-run effect if the config somehow changes

  // Display a loading state or an error if Firebase isn't ready or configured
  if (!isAuthReady) {
    return (
      <div className="flex flex-col items-center justify-center min-h-screen bg-pink-100 p-4 text-center">
        {firebaseProviderMessage ? (
            <p className="text-red-700 text-lg font-bold mb-4">{firebaseProviderMessage}</p>
        ) : (
            <p className="text-pink-700 text-lg">üå∏ Initializing Game... üéÄ</p>
        )}
        <LoadingSpinner theme={CHARACTER_THEMES.Kazhe} />
      </div>
    );
  }

  return (
    <FirebaseContext.Provider value={{ db, auth, userId, effectiveAppId }}>
      {children}
    </FirebaseContext.Provider>
  );
}

// --- Theme Context and Definitions ---
const ThemeContext = createContext(null);

const CHARACTER_THEMES = {
  Kazhe: {
    name: 'Kazhe', primaryBg: 'bg-pink-100', secondaryBg: 'bg-pink-200', accentBg: 'bg-pink-500', accentHover: 'hover:bg-pink-600', textColor: 'text-pink-700', accentText: 'text-pink-800', borderColor: 'border-pink-300', buttonBgSecondary: 'bg-purple-500', buttonHoverSecondary: 'hover:bg-purple-600', buttonBgPrimary: 'bg-pink-500', buttonHoverPrimary: 'hover:bg-pink-600', winnerColor: 'text-purple-700', titleColor: 'text-pink-700', headerBg: 'bg-pink-50', subTitleColor: 'text-purple-600', textMain: 'text-pink-600', inputBorder: 'border-pink-300', inputBg: 'bg-pink-50', inputFocusBorder: 'focus:border-pink-500', inputFocusRing: 'focus:ring-pink-200', placeholderColor: 'placeholder-pink-400', messageSuccessBg: 'bg-blue-300', messageSuccessText: 'text-blue-800', messageErrorBg: 'bg-red-300', messageErrorText: 'text-red-800',
  },
  Ameen: {
    name: 'Ameen', primaryBg: 'bg-red-100', secondaryBg: 'bg-red-200', accentBg: 'bg-red-500', accentHover: 'hover:bg-red-600', textColor: 'text-red-700', accentText: 'text-red-800', borderColor: 'border-red-300', buttonBgSecondary: 'bg-purple-600', buttonHoverSecondary: 'hover:bg-purple-700', buttonBgPrimary: 'bg-red-500', buttonHoverPrimary: 'hover:bg-red-600', winnerColor: 'text-purple-800', titleColor: 'text-red-700', headerBg: 'bg-red-50', subTitleColor: 'text-purple-700', textMain: 'text-red-600', inputBorder: 'border-red-300', inputBg: 'bg-red-50', inputFocusBorder: 'focus:border-red-500', inputFocusRing: 'focus:ring-red-200', placeholderColor: 'placeholder-red-400', messageSuccessBg: 'bg-blue-300', messageSuccessText: 'text-blue-800', messageErrorBg: 'bg-red-300', messageErrorText: 'text-red-800',
  },
  Laja: {
    name: 'Laja', primaryBg: 'bg-emerald-100', secondaryBg: 'bg-emerald-200', accentBg: 'bg-emerald-500', accentHover: 'hover:bg-emerald-600', textColor: 'text-emerald-700', accentText: 'text-emerald-800', borderColor: 'border-emerald-300', buttonBgSecondary: 'bg-purple-500', buttonHoverSecondary: 'hover:bg-purple-600', buttonBgPrimary: 'bg-emerald-500', buttonHoverPrimary: 'hover:bg-emerald-600', winnerColor: 'text-purple-700', titleColor: 'text-emerald-700', headerBg: 'bg-emerald-50', subTitleColor: 'text-purple-600', textMain: 'text-emerald-600', inputBorder: 'border-emerald-300', inputBg: 'bg-emerald-50', inputFocusBorder: 'focus:border-emerald-500', inputFocusRing: 'focus:ring-emerald-200', placeholderColor: 'placeholder-emerald-400', messageSuccessBg: 'bg-blue-300', messageSuccessText: 'text-blue-800', messageErrorBg: 'bg-red-300', messageErrorText: 'text-red-800',
  },
  Chanel: {
    name: 'Chanel', primaryBg: 'bg-blue-100', secondaryBg: 'bg-blue-200', accentBg: 'bg-blue-600', accentHover: 'hover:bg-blue-700', textColor: 'text-blue-800', accentText: 'text-blue-900', borderColor: 'border-blue-300', buttonBgSecondary: 'bg-purple-500', buttonHoverSecondary: 'hover:bg-purple-600', buttonBgPrimary: 'bg-blue-600', buttonHoverPrimary: 'hover:bg-blue-700', winnerColor: 'text-purple-700', titleColor: 'text-blue-700', headerBg: 'bg-blue-50', subTitleColor: 'text-purple-600', textMain: 'text-blue-700', inputBorder: 'border-blue-300', inputBg: 'bg-blue-50', inputFocusBorder: 'focus:border-blue-500', inputFocusRing: 'focus:ring-blue-200', placeholderColor: 'placeholder-blue-400', messageSuccessBg: 'bg-blue-300', messageSuccessText: 'text-blue-800', messageErrorBg: 'bg-red-300', messageErrorText: 'text-red-800',
  }
};

const CHARACTER_NAMES_ARRAY = Object.keys(CHARACTER_THEMES);

// --- Utility Components ---
function MessageBox({ message, type, onClose }) {
  const messageBoxRef = useRef(null);
  const theme = useContext(ThemeContext);

  useEffect(() => {
    if (message) {
      const timer = setTimeout(() => {
        if (onClose) onClose();
      }, 5000);
      return () => clearTimeout(timer);
    }
  }, [message, onClose]);

  if (!message) return null;

  const bgColor = type === 'success' ? theme.messageSuccessBg : theme.messageErrorBg;
  const textColor = type === 'success' ? theme.messageSuccessText : theme.messageErrorText;

  return (
    <div
      ref={messageBoxRef}
      className={`fixed bottom-4 left-1/2 -translate-x-1/2 p-4 rounded-xl shadow-lg z-50 transition-opacity duration-300 ${bgColor} ${textColor}`}
    >
      {message}
      <button
        onClick={onClose}
        className="ml-4 text-sm font-bold bg-transparent border-none cursor-pointer text-current"
      >
        &times;
      </button>
    </div>
  );
}

function LoadingSpinner({ theme }) {
  const activeTheme = theme || CHARACTER_THEMES.Kazhe;
  return (
    <div className={`flex items-center justify-center space-x-2 ${activeTheme.textColor}`}>
      <div className={`w-4 h-4 rounded-full ${activeTheme.accentBg} animate-bounce`}></div>
      <div className={`w-4 h-4 rounded-full ${activeTheme.accentBg} opacity-75 animate-bounce delay-150`}></div>
      <div className={`w-4 h-4 rounded-full ${activeTheme.accentBg} opacity-50 animate-bounce delay-300`}></div>
      <span>Loading...</span>
    </div>
  );
}

// --- Game Constants ---
const DEFAULT_FLASHCARDS = [
  { id: 'q1', question: 'What is the command to initialize a new Git repository?', answer: 'git init' },
  { id: 'q2', question: 'Which command stages changes for commit?', answer: 'git add' },
  { id: 'q3', question: 'How do you commit staged changes with a message?', answer: 'git commit -m "Your message"' },
  { id: 'q4', question: 'What command pulls changes from a remote repository?', answer: 'git pull' },
  { id: 'q5', question: 'How do you create a new branch and switch to it?', answer: 'git checkout -b new-branch' },
  { id: 'q6', question: 'What command merges a branch into your current branch?', answer: 'git merge branch-name' },
  { id: 'q7', question: 'How do you view your commit history?', answer: 'git log' },
  { id: 'q8', question: 'What does `npm install` do?', answer: 'Installs project dependencies' },
  { id: 'q9', question: 'What is JSX in React?', answer: 'JavaScript XML' },
  { id: 'q10', question: 'Which React Hook manages side effects?', answer: 'useEffect' },
];

const MAX_PLAYERS = 4;
const SCORE_PER_QUESTION = 10;

function parseFlashcards(text) {
  const cards = [];
  const lines = text.split('\n');
  lines.forEach((line, index) => {
    const trimmedLine = line.trim();
    if (trimmedLine) {
      const parts = trimmedLine.split('::');
      if (parts.length >= 2) {
        const question = parts[0].trim();
        const answer = parts.slice(1).join('::').trim();
        if (question && answer) {
          cards.push({ id: `custom-${index}`, question, answer });
        }
      }
    }
  });
  return cards;
}

// --- Lobby Component ---
function Lobby({ setGameId, currentGameId, setPlayerName }) {
  const { db, userId, effectiveAppId } = useContext(FirebaseContext);
  const theme = useContext(ThemeContext);
  const [inputGameId, setInputGameId] = useState('');
  const [localPlayerName, setLocalPlayerName] = useState('');
  const [game, setGame] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [message, setMessage] = useState(null);
  const [messageType, setMessageType] = useState('error');
  const [customFlashcardsInput, setCustomFlashcardsInput] = useState('');
  // Use effectiveAppId from FirebaseContext
  const appId = effectiveAppId;

  useEffect(() => {
    const storedName = localStorage.getItem(`study_game_player_name_${appId}`);
    if (storedName) {
      setLocalPlayerName(storedName);
      setPlayerName(storedName);
    } else {
      const defaultNames = ["Cutiepie", "Stardust", "Moonbeam", "Sparkle", "Bubblegum", "Dreamy"];
      const generatedName = defaultNames[Math.floor(Math.random() * defaultNames.length)];
      setLocalPlayerName(generatedName);
      setPlayerName(generatedName);
    }
  }, [appId, setPlayerName]);

  const handlePlayerNameChange = (e) => {
    const name = e.target.value;
    setLocalPlayerName(name);
    setPlayerName(name);
    localStorage.setItem(`study_game_player_name_${appId}`, name);
  };

  const handleCreateGame = async () => {
    if (!localPlayerName.trim()) {
      setMessage('Please enter your player name.');
      setMessageType('error');
      return;
    }
    setIsLoading(true);
    const newGameId = Math.random().toString(36).substring(2, 8).toUpperCase();
    const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', newGameId);
    try {
      await setDoc(gameRef, {
        status: 'lobby',
        players: [{ id: userId, name: localPlayerName, score: 0, lastAnswer: '' }],
        hostId: userId,
        currentQuestionIndex: -1,
        correctAnsweredBy: null,
        questionHistory: [],
        gameTheme: null,
        createdAt: Date.now(),
      });
      setGameId(newGameId);
      setMessage(`Game created! Share ID: ${newGameId}`);
      setMessageType('success');
    } catch (e) {
      console.error("Error creating game:", e);
      setMessage('Failed to create game. Please try again.');
      setMessageType('error');
    } finally {
      setIsLoading(false);
    }
  };

  const handleJoinGame = async () => {
    if (!localPlayerName.trim()) {
      setMessage('Please enter your player name.');
      setMessageType('error');
      return;
    }
    if (!inputGameId.trim()) {
      setMessage('Please enter a Game ID.');
      setMessageType('error');
      return;
    }
    setIsLoading(true);
    const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', inputGameId);
    try {
      await runTransaction(db, async (transaction) => {
        const gameDoc = await transaction.get(gameRef);
        if (!gameDoc.exists()) {
          throw new Error('Game not found.');
        }
        const gameData = gameDoc.data();
        if (gameData.status !== 'lobby') {
          throw new Error('Game has already started or finished.');
        }
        if (gameData.players.length >= MAX_PLAYERS) {
          throw new Error('Game is full.');
        }
        if (gameData.players.some(p => p.id === userId)) {
          // Player already in game, just join the session
        } else {
          transaction.update(gameRef, {
            players: arrayUnion({ id: userId, name: localPlayerName, score: 0, lastAnswer: '' })
          });
        }
      });
      setGameId(inputGameId);
      setMessage(`Joined game ${inputGameId}!`);
      setMessageType('success');
    } catch (e) {
      console.error("Error joining game:", e);
      setMessage(`Failed to join game: ${e.message}`);
      setMessageType('error');
    } finally {
      setIsLoading(false);
    }
  };

  const handleSelectCharacter = async (characterName) => {
    if (!currentGameId || game?.gameTheme) {
      if (game?.gameTheme) {
        setMessage(`Character already selected for this lobby: ${game.gameTheme}`);
      } else {
        setMessage('Please create or join a game first.');
      }
      setMessageType('error');
      return;
    }

    setIsLoading(true);
    const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', currentGameId);
    try {
      await runTransaction(db, async (transaction) => {
        const gameDoc = await transaction.get(gameRef);
        if (!gameDoc.exists()) {
          throw new Error('Game not found.');
        }
        const gameData = gameDoc.data();

        if (gameData.gameTheme) {
          throw new Error(`Theme already set to ${gameData.gameTheme}.`);
        }

        transaction.update(gameRef, {
          gameTheme: characterName,
        });
      });
      setMessage(`Theme set to ${characterName}!`);
      setMessageType('success');
    } catch (e) {
      console.error("Error selecting character:", e);
      setMessage(`Failed to select character: ${e.message}`);
      setMessageType('error');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    let unsubscribe = () => {};
    if (currentGameId && db) {
      const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', currentGameId);
      unsubscribe = onSnapshot(gameRef, (docSnap) => {
        if (docSnap.exists()) {
          const data = docSnap.data();
          setGame(data);
          if (data.status === 'playing') {
            setMessage('Game started!');
            setMessageType('success');
          }
        } else {
          setGame(null);
          setGameId(null);
          setMessage('Game session ended by host or no longer exists.');
          setMessageType('error');
        }
      }, (error) => {
        console.error("Error listening to game:", error);
        setMessage('Lost connection to game. Please refresh.');
        setMessageType('error');
      });
    }
    return () => unsubscribe();
  }, [currentGameId, db, appId, setGameId]);

  const handleStartGame = async () => {
    if (!game || game.hostId !== userId) {
      setMessage('Only the host can start the game.');
      setMessageType('error');
      return;
    }
    if (game.players.length < 2) {
      setMessage('Need at least 2 players to start the game.');
      setMessageType('error');
      return;
    }
    if (!game.gameTheme) {
      setMessage('Please select a character/theme before starting the game!');
      setMessageType('error');
      return;
    }

    setIsLoading(true);
    const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', currentGameId);
    try {
      let gameFlashcards = DEFAULT_FLASHCARDS;
      if (customFlashcardsInput.trim()) {
        const parsedCards = parseFlashcards(customFlashcardsInput);
        if (parsedCards.length > 0) {
          gameFlashcards = parsedCards;
          setMessage(`Loaded ${parsedCards.length} custom flashcards!`);
          setMessageType('success');
        } else {
          setMessage('Could not parse custom flashcards. Using default set.');
          setMessageType('error');
        }
      }

      const shuffledFlashcards = [...gameFlashcards].sort(() => 0.5 - Math.random());
      if (shuffledFlashcards.length === 0) {
        setMessage('No flashcards available to start the game. Please add custom ones or use default.');
        setMessageType('error');
        setIsLoading(false);
        return;
      }

      await updateDoc(gameRef, {
        status: 'playing',
        currentQuestionIndex: 0,
        flashcards: shuffledFlashcards,
        questionHistory: [],
        players: game.players.map(p => ({ ...p, score: 0, lastAnswer: '' })),
      });
      setMessage('Game is starting!');
      setMessageType('success');
    } catch (e) {
      console.error("Error starting game:", e);
      setMessage('Failed to start game.');
      setMessageType('error');
    } finally {
      setIsLoading(false);
    }
  };

  const isHost = game && game.hostId === userId;
  const selectedGameThemeName = game?.gameTheme;
  const isCharacterSelectionDisabled = !!selectedGameThemeName;

  const lobbyTitle = selectedGameThemeName ? `Welcome ${selectedGameThemeName}!` : 'üéÄ Game Lobby üéÄ';

  return (
    <div className={`flex flex-col items-center justify-center p-8 ${theme.primaryBg} rounded-3xl shadow-lg border-4 border-dashed ${theme.borderColor} relative overflow-hidden h-full w-full max-w-lg mx-auto`}>
      <div className={`absolute -top-10 -left-10 w-24 h-24 ${theme.accentBg} rounded-full opacity-30`}></div>
      <div className={`absolute -bottom-10 -right-10 w-24 h-24 ${theme.accentBg} rounded-full opacity-30`}></div>

      <h2 className={`text-3xl font-bold ${theme.titleColor} mb-6 font-comfortaa relative`}>
        {lobbyTitle}
      </h2>

      {currentGameId ? (
        <div className="w-full text-center">
          <p className={`${theme.textMain} text-xl mb-4 font-indie-flower`}>
            Game ID: <span className={`font-bold ${theme.accentText}`}>{currentGameId}</span>
          </p>

          {/* Character Selection */}
          <div className={`${theme.headerBg} p-6 rounded-xl shadow-inner mb-6 w-full max-w-sm mx-auto`}>
            <h3 className={`text-2xl font-semibold ${theme.titleColor} mb-4`}>Choose Your Theme:</h3>
            {selectedGameThemeName && (
              <p className={`text-xl font-bold ${theme.accentText} mb-4`}>
                Theme selected: {selectedGameThemeName} üéâ
              </p>
            )}
            <div className="grid grid-cols-2 gap-4">
              {CHARACTER_NAMES_ARRAY.map(charName => (
                <button
                  key={charName}
                  onClick={() => handleSelectCharacter(charName)}
                  disabled={isLoading || isCharacterSelectionDisabled}
                  className={`flex flex-col items-center p-4 rounded-lg shadow-md transition-all duration-200
                              ${selectedGameThemeName === charName ? `${CHARACTER_THEMES[charName].accentBg} text-white transform scale-105` : `${CHARACTER_THEMES[charName].secondaryBg} ${CHARACTER_THEMES[charName].textColor}`}
                              ${isCharacterSelectionDisabled && selectedGameThemeName !== charName ? 'opacity-50 cursor-not-allowed' : 'hover:scale-105'}
                              ${!isCharacterSelectionDisabled && `hover:${CHARACTER_THEMES[charName].accentBg} hover:text-white`}
                            `}
                >
                  <span className="text-2xl mb-1">{
                    charName === 'Kazhe' ? 'üéÄ' :
                    charName === 'Ameen' ? '‚ù§Ô∏è' :
                    charName === 'Laja' ? 'üåø' :
                    charName === 'Chanel' ? 'üíô' : ''
                  }</span>
                  <span className="font-bold">{charName}</span>
                </button>
              ))}
            </div>
            {isCharacterSelectionDisabled && !selectedGameThemeName && (
                <p className={`${theme.textColor} text-sm mt-2`}>A theme will be automatically set once a player chooses their character.</p>
            )}
          </div>


          <div className={`${theme.headerBg} p-6 rounded-xl shadow-inner mb-6 w-full max-w-sm mx-auto`}>
            <h3 className={`text-2xl font-semibold ${theme.titleColor} mb-4`}>Players Joined:</h3>
            <ul className={`space-y-2 ${theme.textMain} font-comfortaa`}>
              {game && game.players.map(player => (
                <li key={player.id} className="flex items-center justify-between text-lg">
                  <span className="flex items-center">
                    {player.name}
                    {player.id === userId && <span className={`ml-2 text-xs font-bold ${theme.buttonBgPrimary.replace('bg-', 'text-')}`}> (You)</span>}
                    {player.id === game.hostId && <span className="ml-2 text-xs font-bold text-purple-600"> (Host)</span>}
                  </span>
                  <span className={`text-sm ${theme.textColor} truncate`} title={player.id}>{player.id}</span>
                </li>
              ))}
            </ul>
          </div>

          {/* New: Custom Flashcards Input for Host */}
          {isHost && (
            <div className={`${theme.headerBg} p-6 rounded-xl shadow-inner mb-6 w-full mx-auto`}>
              <h3 className={`text-2xl font-semibold ${theme.titleColor} mb-4`}>Your Study Material:</h3>
              <p className={`${theme.textMain} text-sm mb-2`}>Paste flashcards here (Question::Answer, one per line):</p>
              <textarea
                value={customFlashcardsInput}
                onChange={(e) => setCustomFlashcardsInput(e.target.value)}
                placeholder={`Example:\nWhat is a Git commit?::A snapshot of your repository.\nReact Hook for state::useState`}
                rows="5"
                className={`w-full p-3 rounded-lg border-2 ${theme.inputBorder} ${theme.inputBg} ${theme.inputFocusBorder} ${theme.inputFocusRing} ${theme.placeholderColor} ${theme.textColor} text-lg font-comfortaa`}
              ></textarea>
              <p className={`${theme.textMain} text-xs mt-2`}>
                * If left empty, the game will use default coding flashcards.
              </p>
            </div>
          )}


          {isLoading ? (
            <LoadingSpinner theme={theme} />
          ) : (
            isHost && (
              <button
                onClick={handleStartGame}
                disabled={game?.players.length < 2 || isLoading || !game.gameTheme}
                className={`${theme.buttonBgSecondary} ${theme.buttonHoverSecondary} text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed text-lg`}
              >
                {game?.players.length < 2 ? 'Need 2+ Players' : !game.gameTheme ? 'Select a Theme to Start!' : 'Start Game! üöÄ'}
              </button>
            )
          )}
        </div>
      ) : (
        <div className="w-full space-y-4">
          <input
            type="text"
            placeholder="Your Player Name"
            value={localPlayerName}
            onChange={handlePlayerNameChange}
            className={`w-full p-3 rounded-lg border-2 ${theme.inputBorder} ${theme.inputBg} ${theme.inputFocusBorder} ${theme.inputFocusRing} ${theme.placeholderColor} ${theme.textColor} text-lg font-comfortaa`}
          />
          <button
            onClick={handleCreateGame}
            disabled={isLoading}
            className={`w-full ${theme.buttonBgPrimary} ${theme.buttonHoverPrimary} text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed text-lg`}
          >
            {isLoading ? <LoadingSpinner theme={theme} /> : 'Create New Game ÔøΩ'}
          </button>
          <div className="relative flex py-5 items-center">
            <div className={`flex-grow border-t ${theme.borderColor}`}></div>
            <span className={`flex-shrink mx-4 ${theme.textColor} text-xl font-indie-flower`}>or</span>
            <div className={`flex-grow border-t ${theme.borderColor}`}></div>
          </div>
          <input
            type="text"
            placeholder="Enter Game ID"
            value={inputGameId}
            onChange={(e) => setInputGameId(e.target.value.toUpperCase())}
            className={`w-full p-3 rounded-lg border-2 ${theme.inputBorder} ${theme.inputBg} ${theme.inputFocusBorder} ${theme.inputFocusRing} ${theme.placeholderColor} ${theme.textColor} text-lg font-comfortaa`}
          />
          <button
            onClick={handleJoinGame}
            disabled={isLoading}
            className={`w-full ${theme.buttonBgSecondary} ${theme.buttonHoverSecondary} text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed text-lg`}
          >
            {isLoading ? <LoadingSpinner theme={theme} /> : 'Join Existing Game ‚ú®'}
          </button>
        </div>
      )}
      <MessageBox message={message} type={messageType} onClose={() => setMessage(null)} />
    </div>
  );
}

// --- Game Component ---
function Game({ gameId, playerName }) {
  const { db, userId, effectiveAppId } = useContext(FirebaseContext);
  const theme = useContext(ThemeContext);
  const [game, setGame] = useState(null);
  const [currentAnswer, setCurrentAnswer] = useState('');
  const [message, setMessage] = useState(null);
  const [messageType, setMessageType] = useState('error');
  const [isAnswering, setIsAnswering] = useState(false);
  const appId = effectiveAppId; // Use effectiveAppId from FirebaseContext

  useEffect(() => {
    let unsubscribe = () => {};
    if (gameId && db) {
      const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
      unsubscribe = onSnapshot(gameRef, (docSnap) => {
        if (docSnap.exists()) {
          const data = docSnap.data();
          setGame(data);
          if (data.status === 'finished') {
            setMessage('Game Over! See results.');
            setMessageType('success');
          }
          if (data.currentQuestionIndex !== (game?.currentQuestionIndex || -1)) {
            setCurrentAnswer('');
            setIsAnswering(false);
          }
        } else {
          setMessage('Game session ended or no longer exists.');
          setMessageType('error');
        }
      }, (error) => {
        console.error("Error listening to game state:", error);
        setMessage('Lost connection to game. Please refresh.');
        setMessageType('error');
      });
    }
    return () => unsubscribe();
  }, [gameId, db, appId, game?.currentQuestionIndex]);

  const currentQuestion = game?.flashcards?.[game.currentQuestionIndex];
  const playerList = game?.players || [];
  const currentPlayer = playerList.find(p => p.id === userId);

  const handleSubmitAnswer = async (e) => {
    e.preventDefault();
    if (!currentQuestion || !currentAnswer.trim() || isAnswering || game.correctAnsweredBy) {
      if (game.correctAnsweredBy) {
          setMessage('This question has already been answered correctly!');
          setMessageType('error');
      } else if (!currentAnswer.trim()){
          setMessage('Please type an answer!');
          setMessageType('error');
      }
      return;
    }

    setIsAnswering(true);
    const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);

    try {
      await runTransaction(db, async (transaction) => {
        const gameDoc = await transaction.get(gameRef);
        if (!gameDoc.exists()) {
          throw new Error('Game no longer exists.');
        }
        const gameData = gameDoc.data();

        if (gameData.correctAnsweredBy) {
          throw new Error('This question has already been answered correctly by another player.');
        }

        const normalizedSubmittedAnswer = currentAnswer.trim().toLowerCase();
        const normalizedCorrectAnswer = currentQuestion.answer.trim().toLowerCase();

        if (normalizedSubmittedAnswer === normalizedCorrectAnswer) {
          const updatedPlayers = gameData.players.map(p =>
            p.id === userId ? { ...p, score: p.score + SCORE_PER_QUESTION, lastAnswer: currentAnswer } : p
          );

          transaction.update(gameRef, {
            players: updatedPlayers,
            correctAnsweredBy: userId,
            questionHistory: arrayUnion({
              questionId: currentQuestion.id,
              correctAnswer: currentQuestion.answer,
              answeredBy: userId,
              submittedAnswer: currentAnswer,
              timestamp: Date.now()
            })
          });
          setMessage('Correct! üíñ');
          setMessageType('success');
        } else {
          const updatedPlayers = gameData.players.map(p =>
            p.id === userId ? { ...p, lastAnswer: currentAnswer } : p
          );
          transaction.update(gameRef, { players: updatedPlayers });
          setMessage('Incorrect answer. Try again or wait for the next question!');
          setMessageType('error');
        }
      });
    } catch (e) {
      console.error("Error submitting answer:", e);
      setMessage(`Error: ${e.message}`);
      setMessageType('error');
    } finally {
      setIsAnswering(false);
    }
  };

  const handleNextQuestion = async () => {
    if (!game || !game.correctAnsweredBy) {
      setMessage('Please answer the current question correctly first!');
      setMessageType('error');
      return;
    }

    setIsAnswering(true);
    const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
    try {
      const nextIndex = game.currentQuestionIndex + 1;
      if (nextIndex < game.flashcards.length) {
        await updateDoc(gameRef, {
          currentQuestionIndex: nextIndex,
          correctAnsweredBy: null,
          players: playerList.map(p => ({ ...p, lastAnswer: '' }))
        });
        setMessage('Next question!');
        setMessageType('success');
      } else {
        await updateDoc(gameRef, {
          status: 'finished',
          correctAnsweredBy: null,
        });
        setMessage('Game finished! Displaying results.');
        setMessageType('success');
      }
    } catch (e) {
      console.error("Error advancing question:", e);
      setMessage('Failed to advance question.');
      setMessageType('error');
    } finally {
      setIsAnswering(false);
    }
  };

  if (!game) {
    return <LoadingSpinner theme={theme} />;
  }

  const isLobby = game.status === 'lobby';
  const isPlaying = game.status === 'playing';
  const isFinished = game.status === 'finished';

  if (isLobby) {
    return <p className={`${theme.textColor}`}>Waiting for game to start...</p>;
  }

  if (isFinished) {
    return (
      <EndScreen game={game} />
    );
  }

  return (
    <div className={`flex flex-col items-center p-8 ${theme.primaryBg} rounded-3xl shadow-lg border-4 border-dashed ${theme.borderColor} relative overflow-hidden h-full w-full max-w-lg mx-auto`}>
      <h2 className={`text-3xl font-bold ${theme.titleColor} mb-6 font-comfortaa relative`}>
        üå∏ Quiz Time! üéÄ
      </h2>

      <div className={`w-full ${theme.headerBg} p-6 rounded-xl shadow-inner mb-6`}>
        <h3 className={`text-xl font-semibold ${theme.titleColor} mb-3`}>Question {game.currentQuestionIndex + 1} / {game.flashcards.length}:</h3>
        <p className={`text-2xl font-bold ${theme.subTitleColor} mb-4 font-comfortaa break-words`}>
          {currentQuestion?.question || 'Loading question...'}
        </p>

        {game.correctAnsweredBy ? (
            <p className="text-green-600 font-bold text-xl mt-4">
                <span className={`${theme.subTitleColor} font-bold`}>
                    {playerList.find(p => p.id === game.correctAnsweredBy)?.name || 'Someone'}
                </span> got it right! The answer was: <span className={`${theme.textMain} font-bold`}>{currentQuestion?.answer}</span>
            </p>
        ) : (
            <form onSubmit={handleSubmitAnswer} className="flex flex-col gap-4">
                <input
                    type="text"
                    value={currentAnswer}
                    onChange={(e) => setCurrentAnswer(e.target.value)}
                    placeholder="Type your answer here..."
                    className={`w-full p-3 rounded-lg border-2 ${theme.inputBorder} ${theme.inputBg} ${theme.inputFocusBorder} ${theme.inputFocusRing} ${theme.placeholderColor} ${theme.textColor} text-lg font-comfortaa`}
                    disabled={isAnswering}
                />
                <button
                    type="submit"
                    className={`${theme.buttonBgSecondary} ${theme.buttonHoverSecondary} text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed text-lg`}
                    disabled={isAnswering || !currentAnswer.trim()}
                >
                    {isAnswering ? <LoadingSpinner theme={theme} /> : 'Submit Answer ‚ú®'}
                </button>
            </form>
        )}
      </div>

      <div className={`w-full ${theme.headerBg} p-6 rounded-xl shadow-inner mb-6`}>
        <h3 className={`text-xl font-semibold ${theme.titleColor} mb-4`}>Scoreboard:</h3>
        <ul className={`space-y-2 ${theme.textMain} font-comfortaa`}>
          {playerList.sort((a,b) => b.score - a.score).map(player => (
            <li key={player.id} className="flex items-center justify-between text-lg">
              <span className="flex items-center">
                {player.name}
                {player.id === userId && <span className={`ml-2 text-xs font-bold ${theme.buttonBgPrimary.replace('bg-', 'text-')}`}> (You)</span>}
              </span>
              <span className={`${theme.accentText} font-bold`}>{player.score} points</span>
              {player.lastAnswer && <span className={`ml-2 text-xs ${theme.textColor} opacity-70 italic`}> - {player.lastAnswer}</span>}
            </li>
          ))}
        </ul>
      </div>

      <button
        onClick={handleNextQuestion}
        disabled={!game.correctAnsweredBy && game.currentQuestionIndex < game.flashcards.length -1}
        className={`${theme.buttonBgPrimary} ${theme.buttonHoverPrimary} text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed text-lg`}
      >
        {game.currentQuestionIndex < game.flashcards.length - 1 ? 'Next Question üöÄ' : 'Finish Game! üéâ'}
      </button>
      <MessageBox message={message} type={messageType} onClose={() => setMessage(null)} />
    </div>
  );
}

// --- EndScreen Component ---
function EndScreen({ game }) {
  const theme = useContext(ThemeContext);
  const sortedPlayers = [...game.players].sort((a, b) => b.score - a.score);
  const winner = sortedPlayers[0];

  return (
    <div className={`flex flex-col items-center justify-center p-8 ${theme.primaryBg} rounded-3xl shadow-lg border-4 border-dashed ${theme.borderColor} relative overflow-hidden h-full w-full max-w-lg mx-auto`}>
      <h2 className={`text-4xl font-bold ${theme.titleColor} mb-6 font-comfortaa animate-bounce`}>
        Game Over! üéâ
      </h2>

      <div className={`bg-white p-8 rounded-xl shadow-inner mb-8 w-full max-w-sm mx-auto`}>
        <h3 className={`text-3xl font-semibold ${theme.subTitleColor} mb-6`}>Final Scores:</h3>
        <ul className={`space-y-3 ${theme.textMain} font-comfortaa text-xl`}>
          {sortedPlayers.map((player, index) => (
            <li key={player.id} className="flex items-center justify-between">
              <span className="font-bold">
                {index === 0 ? 'üèÜ ' : ''}{player.name}
              </span>
              <span className={`${theme.accentText} font-bold`}>{player.score} points</span>
            </li>
          ))}
        </ul>
      </div>

      {winner && (
        <p className={`text-3xl font-bold ${theme.titleColor} font-indie-flower mb-8`}>
          Winner: <span className={`${theme.winnerColor}`}>{winner.name}</span>! Congratulations! üëë
        </p>
      )}

      <button
        onClick={() => window.location.reload()}
        className={`${theme.buttonBgPrimary} ${theme.buttonHoverPrimary} text-white font-bold py-3 px-6 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105 text-lg`}
      >
        Play Again? üíñ
      </button>
    </div>
  );
}

// --- Main GameWrapper Component ---
function GameWrapper() {
  const [currentGameId, setCurrentGameId] = useState(null);
  const [gameStatus, setGameStatus] = useState('lobby');
  const [playerName, setPlayerName] = useState('');
  const [activeGameTheme, setActiveGameTheme] = useState(CHARACTER_THEMES.Kazhe);
  const { db, userId, effectiveAppId } = useContext(FirebaseContext); // Get effectiveAppId from context

  useEffect(() => {
    let unsubscribe = () => {};
    if (currentGameId && db) {
      const gameRef = doc(db, 'artifacts', effectiveAppId, 'public', 'data', 'games', currentGameId); // Use effectiveAppId
      unsubscribe = onSnapshot(gameRef, (docSnap) => {
        if (docSnap.exists()) {
          const gameData = docSnap.data();
          setGameStatus(gameData.status);
          if (gameData.gameTheme && CHARACTER_THEMES[gameData.gameTheme]) {
            setActiveGameTheme(CHARACTER_THEMES[gameData.gameTheme]);
          } else {
            setActiveGameTheme(CHARACTER_THEMES.Kazhe);
          }
        } else {
          setCurrentGameId(null);
          setGameStatus('lobby');
          setActiveGameTheme(CHARACTER_THEMES.Kazhe);
        }
      }, (error) => {
        console.error("Error listening to game in App.js:", error);
        setCurrentGameId(null);
        setGameStatus('lobby');
        setActiveGameTheme(CHARACTER_THEMES.Kazhe);
      });
    }
    return () => unsubscribe();
  }, [currentGameId, db, effectiveAppId]); // Depend on effectiveAppId

  const renderGameComponent = () => {
    switch (gameStatus) {
      case 'playing':
      case 'finished':
        return <Game gameId={currentGameId} playerName={playerName} />;
      case 'lobby':
      default:
        return <Lobby setGameId={setCurrentGameId} currentGameId={currentGameId} setPlayerName={setPlayerName} />;
    }
  };

  return (
    <div className={`min-h-screen flex items-center justify-center p-4 bg-gradient-to-br from-pink-50 to-purple-100`}>
      <style>{`
        /* Tailwind CSS CDN */
        @import url('https://cdn.tailwindcss.com');
        /* Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;700&family=Indie+Flower&display=swap');
        /* Custom styles for bouncing animation */
        @keyframes bounce {
            0%, 100% {
                transform: translateY(-25%);
                animation-timing-function: cubic-bezier(0.8,0,1,1);
            }
            50% {
                transform: none;
                animation-timing-function: cubic-bezier(0,0,0.2,1);
            }
        }
        .animate-bounce {
            animation: bounce 1s infinite;
        }
      `}</style>
      <ThemeContext.Provider value={activeGameTheme}>
        {renderGameComponent()}
      </ThemeContext.Provider>
    </div>
  );
}

// --- Root App Component ---
function App() {
  return (
    <FirebaseProvider>
      <GameWrapper />
    </FirebaseProvider>
  );
}

export default App;
ÔøΩ
